---
title: Can machine learning change your lifestyle? Predicting Diabetes
description: "predictive modeling algorithms - for learners"
author: ''
date: '2019-10-01'
output:
    html_document:
        highlight: tango
slug: predict-diseases
categories: []
tags:
  - Machine learning
  - Blog
  - Data Science Process
  - Linear Regression
  - Logistic Regression
  - glmnet
  - Randomforest
  - Data Quality control
  - Feature engineering
  - Pima Indians
subtitle: ''
summary: ''
authors: []
lastmod: '2019-10-01T09:09:36+02:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---



<p>We are developing new technologies at lightning speed. We can now analyse genes from a single cell which was not even possible couple of years back, and extract the knowledge hidden in rare genes or rare cell types.</p>
<p>Sensors collect real time data from patients e.g. in diabetic patients, we started to pool data (real world evidence) generated during the actual use of drugs by patients (e.g. <a href="https://www.ohdsi.org/data-standardization/the-common-data-model/">OMOP common data model</a>. <strong>The data that we have access now is enormous and is growing rapidly.</strong></p>
<p><strong>Data Science</strong> tools are more than ever needed to mold this data into better therapies.</p>
<p>We can build new machine learning models and;</p>
<ul>
<li><strong>diagnose diseases earlier</strong></li>
<li><strong>develop better drugs which are more effective and have less side effects</strong></li>
<li><strong>identify patient groups which benefit most from existing drugs</strong></li>
</ul>
<p><strong>Let’s look at an example</strong> and see how we can do this.</p>
<p>First part in any data science process is <strong>problem formulation.</strong></p>
<div id="problem-formulation" class="section level1">
<h1>Problem formulation</h1>
<p>Our problem, or question that we want to answer is:</p>
<blockquote>
<p>Can we predict which patients will develop Diabetes by building a Machine learning algorithm?</p>
</blockquote>
<p>We will predict a Binary <strong>Outcome</strong>: <code>Diabetes</code> vs <code>Healthy</code>
by using 8 medical indicators.</p>
</div>
<div id="overview-of-the-data" class="section level1">
<h1>Overview of the data</h1>
<p><strong>The Pima Indians of Arizona and Mexico</strong> have contributed to numerous scientific gains. Their involvement has led to significant findings on genetics of both <strong>type 2 diabetes</strong> and <strong>obesity.</strong></p>
<p>The medical indicators recorded are;</p>
<p><strong>Pregnancies:</strong> Number of times pregnant<br />
<strong>Glucose:</strong> Plasma glucose concentration a 2 hours in an oral glucose tolerance test<br />
<strong>BloodPressure:</strong> Diastolic blood pressure (mm Hg)<br />
<strong>SkinThickness:</strong> Triceps skin fold thickness (mm)<br />
<strong>Insulin:</strong> 2-Hour serum insulin (mu U/ml)<br />
<strong>BMI:</strong> Body mass index (weight in kg/(height in m)^2)<br />
<strong>DiabetesPedigreeFunction:</strong> Diabetes pedigree function<br />
<strong>Age:</strong> Age (years)<br />
<strong>Outcome:</strong> Class variable (0 or 1)</p>
</div>
<div id="data-acquisition" class="section level1">
<h1>Data acquisition</h1>
<p>You can download the <a href="https://www.kaggle.com/uciml/pima-indians-diabetes-database">Pima Indians Diabetes Dataset</a> from Kaggle and load it in RStudio.</p>
<p>Setting up and loading in the data.</p>
<pre class="r"><code>diabetes &lt;- read.csv(&quot;posts_data/diabetes.csv&quot;)
library(tidyverse) # Includes packages: ggplot2, dplyr, tidyr, readr, 
                   # purrr, tibble, stringr, forcats
library(reshape2) # Main function: melt()
library(ggcorrplot)
library(pROC)
library(lattice)
library(caret)
library(waffle)
library(compareGroups) # Main functions: compareGroups(), createTable()</code></pre>
<p>Next step in our data science process is to check whether the data quality is good.</p>
</div>
<div id="data-quality-control" class="section level1">
<h1>Data Quality control</h1>
<p>Before running any algorithm a good starting point is to <strong>check obvious mistakes and abnormalities in your data.</strong></p>
<p>I would first look at <strong>Missing values</strong>, <strong>NAs</strong>, variable ranges (<strong>min, max values</strong>). A very extreme value might be basically a typing error.</p>
<div id="understand-your-data" class="section level2">
<h2>Understand your Data</h2>
<p>How big is the data? Classes of variables?</p>
<pre class="r"><code>dim(diabetes)</code></pre>
<pre><code>## [1] 768   9</code></pre>
<pre class="r"><code>knitr::kable(sapply(diabetes, class))</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:left;">
x
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Pregnancies
</td>
<td style="text-align:left;">
integer
</td>
</tr>
<tr>
<td style="text-align:left;">
Glucose
</td>
<td style="text-align:left;">
integer
</td>
</tr>
<tr>
<td style="text-align:left;">
BloodPressure
</td>
<td style="text-align:left;">
integer
</td>
</tr>
<tr>
<td style="text-align:left;">
SkinThickness
</td>
<td style="text-align:left;">
integer
</td>
</tr>
<tr>
<td style="text-align:left;">
Insulin
</td>
<td style="text-align:left;">
integer
</td>
</tr>
<tr>
<td style="text-align:left;">
BMI
</td>
<td style="text-align:left;">
numeric
</td>
</tr>
<tr>
<td style="text-align:left;">
DiabetesPedigreeFunction
</td>
<td style="text-align:left;">
numeric
</td>
</tr>
<tr>
<td style="text-align:left;">
Age
</td>
<td style="text-align:left;">
integer
</td>
</tr>
<tr>
<td style="text-align:left;">
Outcome
</td>
<td style="text-align:left;">
integer
</td>
</tr>
</tbody>
</table>
<p>I look which atomic data types my variables are. I see that the outcome variable is represented as an <strong>integer.</strong> We will keep this in mind because many machine learning models will accept the binary outcome when converted to a factor atomic data type.</p>
<p>Next, what catches my attention is <strong>unexpected zeros in Insulin</strong>. See below.</p>
<pre class="r"><code>knitr::kable(head(diabetes))</code></pre>
<table>
<thead>
<tr>
<th style="text-align:right;">
Pregnancies
</th>
<th style="text-align:right;">
Glucose
</th>
<th style="text-align:right;">
BloodPressure
</th>
<th style="text-align:right;">
SkinThickness
</th>
<th style="text-align:right;">
Insulin
</th>
<th style="text-align:right;">
BMI
</th>
<th style="text-align:right;">
DiabetesPedigreeFunction
</th>
<th style="text-align:right;">
Age
</th>
<th style="text-align:right;">
Outcome
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
6
</td>
<td style="text-align:right;">
148
</td>
<td style="text-align:right;">
72
</td>
<td style="text-align:right;">
35
</td>
<td style="text-align:right;">
0
</td>
<td style="text-align:right;">
33.6
</td>
<td style="text-align:right;">
0.627
</td>
<td style="text-align:right;">
50
</td>
<td style="text-align:right;">
1
</td>
</tr>
<tr>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
85
</td>
<td style="text-align:right;">
66
</td>
<td style="text-align:right;">
29
</td>
<td style="text-align:right;">
0
</td>
<td style="text-align:right;">
26.6
</td>
<td style="text-align:right;">
0.351
</td>
<td style="text-align:right;">
31
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:right;">
8
</td>
<td style="text-align:right;">
183
</td>
<td style="text-align:right;">
64
</td>
<td style="text-align:right;">
0
</td>
<td style="text-align:right;">
0
</td>
<td style="text-align:right;">
23.3
</td>
<td style="text-align:right;">
0.672
</td>
<td style="text-align:right;">
32
</td>
<td style="text-align:right;">
1
</td>
</tr>
<tr>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
89
</td>
<td style="text-align:right;">
66
</td>
<td style="text-align:right;">
23
</td>
<td style="text-align:right;">
94
</td>
<td style="text-align:right;">
28.1
</td>
<td style="text-align:right;">
0.167
</td>
<td style="text-align:right;">
21
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:right;">
0
</td>
<td style="text-align:right;">
137
</td>
<td style="text-align:right;">
40
</td>
<td style="text-align:right;">
35
</td>
<td style="text-align:right;">
168
</td>
<td style="text-align:right;">
43.1
</td>
<td style="text-align:right;">
2.288
</td>
<td style="text-align:right;">
33
</td>
<td style="text-align:right;">
1
</td>
</tr>
<tr>
<td style="text-align:right;">
5
</td>
<td style="text-align:right;">
116
</td>
<td style="text-align:right;">
74
</td>
<td style="text-align:right;">
0
</td>
<td style="text-align:right;">
0
</td>
<td style="text-align:right;">
25.6
</td>
<td style="text-align:right;">
0.201
</td>
<td style="text-align:right;">
30
</td>
<td style="text-align:right;">
0
</td>
</tr>
</tbody>
</table>
</div>
<div id="missing-values" class="section level2">
<h2>Missing Values</h2>
<p>Summary gives a good overview of the variables. Any missing data would show up here listed as <strong>“NA’s”</strong>. But we have none here.</p>
<pre class="r"><code>summary(diabetes)</code></pre>
<pre><code>##   Pregnancies        Glucose      BloodPressure    SkinThickness  
##  Min.   : 0.000   Min.   :  0.0   Min.   :  0.00   Min.   : 0.00  
##  1st Qu.: 1.000   1st Qu.: 99.0   1st Qu.: 62.00   1st Qu.: 0.00  
##  Median : 3.000   Median :117.0   Median : 72.00   Median :23.00  
##  Mean   : 3.845   Mean   :120.9   Mean   : 69.11   Mean   :20.54  
##  3rd Qu.: 6.000   3rd Qu.:140.2   3rd Qu.: 80.00   3rd Qu.:32.00  
##  Max.   :17.000   Max.   :199.0   Max.   :122.00   Max.   :99.00  
##     Insulin           BMI        DiabetesPedigreeFunction      Age       
##  Min.   :  0.0   Min.   : 0.00   Min.   :0.0780           Min.   :21.00  
##  1st Qu.:  0.0   1st Qu.:27.30   1st Qu.:0.2437           1st Qu.:24.00  
##  Median : 30.5   Median :32.00   Median :0.3725           Median :29.00  
##  Mean   : 79.8   Mean   :31.99   Mean   :0.4719           Mean   :33.24  
##  3rd Qu.:127.2   3rd Qu.:36.60   3rd Qu.:0.6262           3rd Qu.:41.00  
##  Max.   :846.0   Max.   :67.10   Max.   :2.4200           Max.   :81.00  
##     Outcome     
##  Min.   :0.000  
##  1st Qu.:0.000  
##  Median :0.000  
##  Mean   :0.349  
##  3rd Qu.:1.000  
##  Max.   :1.000</code></pre>
<p>Plotting how the variables are distributed will give a good overview to spot problems.</p>
<p>I will change the data format so that I can plot all the variables in different facets. <strong>melt()</strong> function from reshape2 package can create a tall version of my data.</p>
<p><strong>This function will collect all variable names in one column and corresponding values in the next column.</strong> This data structure will allow me to plot all variables together.</p>
<pre class="r"><code>gg &lt;- melt(diabetes)

# Check how the new data structure looks like
head(gg)</code></pre>
<pre><code>##      variable value
## 1 Pregnancies     6
## 2 Pregnancies     1
## 3 Pregnancies     8
## 4 Pregnancies     1
## 5 Pregnancies     0
## 6 Pregnancies     5</code></pre>
<pre class="r"><code># Plot all variables
ggplot(gg, aes(x=value, fill=variable)) +
  geom_histogram(binwidth=5) + 
  theme(legend.position = &quot;none&quot;) +
  facet_wrap(~variable) </code></pre>
<p><img src="/post/2019-10-01-can-machine-learning-change-your-life-style_files/figure-html/Check%20out%20how%20the%20variables%20are%20distributed-1.png" width="672" /></p>
<p>Multiple variables have peaks at zero. E.g. Skin Thickness and Insulin. It is not possible that those variables are zero.</p>
<p>I want to know how many zeros each variables has. In cases where the numbers are small we might remove them. <strong>Let’s figure it out with a for loop.</strong> and then visualize on a waffle plot.</p>
<p>I am selecting only variables from 2 to 6 because only those can’t be zero. Let’s count number of zeros.</p>
<p><strong>How to count zeros in each column?</strong></p>
<p><strong>Approach 1:</strong> Using a for loop, which() function and []</p>
<pre class="r"><code>zero_rows &lt;- list()
for(i in 2:6){
zero_rows[[i]] &lt;- length(which(diabetes[,i] == 0))  
}
rows_with_zero &lt;- unlist(zero_rows)
rows_with_zero</code></pre>
<pre><code>## [1]   5  35 227 374  11</code></pre>
<p>As a bonus, I- can recommend using dplyr package.</p>
<p><strong>Approach 2:</strong> Much simpler with dplyr <strong>summarise_all()</strong> function</p>
<pre class="r"><code>zeros &lt;- diabetes[,2:6] %&gt;%  summarise_all(funs(sum(.==0)))
t(zeros)</code></pre>
<pre><code>##               [,1]
## Glucose          5
## BloodPressure   35
## SkinThickness  227
## Insulin        374
## BMI             11</code></pre>
<p>Feed those numbers into a waffle plot.</p>
<pre class="r"><code>zeros &lt;- c(&quot;Glucose&quot; =zeros[1,1], &quot;Blood Pressure&quot; = zeros[1,2], 
           &quot;Skin Thickness&quot;= zeros[1,3], &quot;Insulin&quot; =zeros[1,4], 
           &quot;BMI&quot; = zeros[1,5])
waffle(zeros, rows=20) + 
  theme(text = element_text(size=15)) + 
  ggtitle(&quot;Number of rows with zero&quot;)</code></pre>
<p><img src="/post/2019-10-01-can-machine-learning-change-your-life-style_files/figure-html/waffle%20plot%20of%20zero%20values-1.png" width="672" /></p>
<p>For instance, <strong>374</strong> rows of Insulin are zero. Other variables also contain zeros. Something is wrong. It is impossible to have Blood Pressure or Glucose levels at 0. It is unlikely that those are simply entry mistakes. It seems missing values are filled with <strong>zeros</strong> in the data collection phase.</p>
<p><strong>How to circumvent this?</strong></p>
<div id="convert-all-zeroes-to-nas-and-then-perform-median-imputation" class="section level3">
<h3>Convert all <strong>zeroes</strong> to <strong>NAs</strong> and then perform <strong>Median Imputation</strong></h3>
<p>Most models require numbers, and can’t handle missing data. Throwing out rows is not a good idea since it can lead to biases in your dataset and generate overconfident models.</p>
<p>Median imputation lets you model data with missing values. By replacing them with their medians.</p>
<p>To do this, I need to change zeros to missing values. I will do this for all the predictors which zero is not plausible(columns 2 to 6).</p>
<pre class="r"><code>for(i in 2:6){
# Convert zeros to NAs
diabetes[, i][diabetes[, i] == 0] &lt;- NA
# Calculate median
median &lt;- median(diabetes[, i], na.rm = TRUE)
diabetes[, i][is.na(diabetes[, i])] &lt;- median
}</code></pre>
<p>Check if it really happened.</p>
<pre class="r"><code>knitr::kable(head(diabetes))</code></pre>
<table>
<thead>
<tr>
<th style="text-align:right;">
Pregnancies
</th>
<th style="text-align:right;">
Glucose
</th>
<th style="text-align:right;">
BloodPressure
</th>
<th style="text-align:right;">
SkinThickness
</th>
<th style="text-align:right;">
Insulin
</th>
<th style="text-align:right;">
BMI
</th>
<th style="text-align:right;">
DiabetesPedigreeFunction
</th>
<th style="text-align:right;">
Age
</th>
<th style="text-align:right;">
Outcome
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
6
</td>
<td style="text-align:right;">
148
</td>
<td style="text-align:right;">
72
</td>
<td style="text-align:right;">
35
</td>
<td style="text-align:right;">
125
</td>
<td style="text-align:right;">
33.6
</td>
<td style="text-align:right;">
0.627
</td>
<td style="text-align:right;">
50
</td>
<td style="text-align:right;">
1
</td>
</tr>
<tr>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
85
</td>
<td style="text-align:right;">
66
</td>
<td style="text-align:right;">
29
</td>
<td style="text-align:right;">
125
</td>
<td style="text-align:right;">
26.6
</td>
<td style="text-align:right;">
0.351
</td>
<td style="text-align:right;">
31
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:right;">
8
</td>
<td style="text-align:right;">
183
</td>
<td style="text-align:right;">
64
</td>
<td style="text-align:right;">
29
</td>
<td style="text-align:right;">
125
</td>
<td style="text-align:right;">
23.3
</td>
<td style="text-align:right;">
0.672
</td>
<td style="text-align:right;">
32
</td>
<td style="text-align:right;">
1
</td>
</tr>
<tr>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
89
</td>
<td style="text-align:right;">
66
</td>
<td style="text-align:right;">
23
</td>
<td style="text-align:right;">
94
</td>
<td style="text-align:right;">
28.1
</td>
<td style="text-align:right;">
0.167
</td>
<td style="text-align:right;">
21
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:right;">
0
</td>
<td style="text-align:right;">
137
</td>
<td style="text-align:right;">
40
</td>
<td style="text-align:right;">
35
</td>
<td style="text-align:right;">
168
</td>
<td style="text-align:right;">
43.1
</td>
<td style="text-align:right;">
2.288
</td>
<td style="text-align:right;">
33
</td>
<td style="text-align:right;">
1
</td>
</tr>
<tr>
<td style="text-align:right;">
5
</td>
<td style="text-align:right;">
116
</td>
<td style="text-align:right;">
74
</td>
<td style="text-align:right;">
29
</td>
<td style="text-align:right;">
125
</td>
<td style="text-align:right;">
25.6
</td>
<td style="text-align:right;">
0.201
</td>
<td style="text-align:right;">
30
</td>
<td style="text-align:right;">
0
</td>
</tr>
</tbody>
</table>
<p>For instance, I see that zero values in the insulin variable is replaced with median of insulin which is 125.</p>
<p>I will also look at the differences between variables in diabetic versus healthy groups so that I know more which variables might play a role in the Outcome.</p>
<p>I can also use dplyr functions but I will use <strong>compareGroups</strong> package because it creates a nice output of the summary statistics in a table format. compareGroups() function will do the analysis and createTable() will output it in a nice format.</p>
<pre class="r"><code>base &lt;- compareGroups(Outcome~Pregnancies+Glucose+BloodPressure+
                        SkinThickness+Insulin+BMI +
                        DiabetesPedigreeFunction+Age, 
                        data = diabetes)

summary_stats &lt;- createTable(base, show.ratio = FALSE, show.p.overall=TRUE)
summary_stats</code></pre>
<pre><code>## 
## --------Summary descriptives table by &#39;Outcome&#39;---------
## 
## __________________________________________________________ 
##                               0           1      p.overall 
##                             N=500       N=268              
## ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ 
## Pregnancies              3.30 (3.02) 4.87 (3.74)  &lt;0.001   
## Glucose                  111 (24.7)  142 (29.6)   &lt;0.001   
## BloodPressure            70.9 (11.9) 75.1 (12.0)  &lt;0.001   
## SkinThickness            27.7 (8.55) 31.7 (8.66)  &lt;0.001   
## Insulin                  128 (74.4)   165 (101)   &lt;0.001   
## BMI                      30.9 (6.50) 35.4 (6.60)  &lt;0.001   
## DiabetesPedigreeFunction 0.43 (0.30) 0.55 (0.37)  &lt;0.001   
## Age                      31.2 (11.7) 37.1 (11.0)  &lt;0.001   
## ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯</code></pre>
<p>You can see here that couple of variables are significantly higher in diabetic patients, such as Pregnancies, glucose, insulin, bmi and so on. This can give hints on what to expect from the linear model.</p>
<p>So far, we made some visualizations to understand the dataset better, made some quality checks and cleaning.</p>
<p><strong>Now, the data is ready for the modeling phase.</strong></p>
</div>
</div>
</div>
<div id="modeling-the-data-build-fit-and-validate-a-model" class="section level1">
<h1>Modeling the data (build, fit and validate a model)</h1>
<p>Before going into any complicated model starting with a simple model is a good idea. It might do surprisingly well and will give us more insights.</p>
<div id="model-assumptions" class="section level2">
<h2>Model assumptions</h2>
<p>One of the assumptions of logistic regression that it requires large sample size.</p>
<div id="what-should-be-the-minimum-sample-size-for-running-logistic-regression" class="section level3">
<h3>What should be the minimum sample size for running logistic regression?</h3>
<p>Minimum sample size is given by the following formula:</p>
<p>N = 10 k / p</p>
<p>where,</p>
<p>p is the proportion of the least frequent class of the Outcome variable. We have 768 cases of which 500 are diabetic and 268 non diabetic.</p>
<p>p = 268/768 = 0.34</p>
<p>And k is the number of covariates ( the number of predictor variables)</p>
<p>k = 8</p>
<p>N = 10 * 8 / 268/768
N = 229</p>
<p>Since we have a total of 768 cases we can apply logistic regression model.</p>
</div>
</div>
<div id="logistic-regression-model" class="section level2">
<h2>Logistic Regression Model</h2>
<p>We will create two random subsets of our data in 80/20 proportion as <strong>training and test data.</strong> Training data will be used to build our model and test data will be reserved to validate it.</p>
<pre class="r"><code>set.seed(22)
# Create train test split
sample_rows &lt;- sample(nrow(diabetes), nrow(diabetes) * 0.8)
# Create the training dataset
dia_train &lt;- diabetes[sample_rows, ]
# Create the test dataset
dia_test &lt;- diabetes[-sample_rows, ]</code></pre>
<pre class="r"><code># Build a logistic regression model with the train data
glm_dia &lt;- glm(Outcome ~ .,data = dia_train, family = &quot;binomial&quot;)
summary(glm_dia)</code></pre>
<pre><code>## 
## Call:
## glm(formula = Outcome ~ ., family = &quot;binomial&quot;, data = dia_train)
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -2.5941  -0.7143  -0.3887   0.7330   2.1417  
## 
## Coefficients:
##                           Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept)              -9.371525   0.926425 -10.116  &lt; 2e-16 ***
## Pregnancies               0.108782   0.036022   3.020 0.002529 ** 
## Glucose                   0.036465   0.004309   8.462  &lt; 2e-16 ***
## BloodPressure            -0.010359   0.009470  -1.094 0.273974    
## SkinThickness             0.005730   0.014928   0.384 0.701105    
## Insulin                  -0.002056   0.001279  -1.607 0.107995    
## BMI                       0.102303   0.021009   4.870 1.12e-06 ***
## DiabetesPedigreeFunction  1.154731   0.327099   3.530 0.000415 ***
## Age                       0.021617   0.010619   2.036 0.041780 *  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 793.94  on 613  degrees of freedom
## Residual deviance: 570.22  on 605  degrees of freedom
## AIC: 588.22
## 
## Number of Fisher Scoring iterations: 5</code></pre>
<p>The summary shows us not all the variables play a role in predicting outcome. The significant correlations was found for Pregnancies, Glucose, BMI and Pedigree function.</p>
<p>The predict function will give us probabilities. To compute our model accuracy we need to <strong>convert them to class predictions by setting a threshold level.</strong></p>
<pre class="r"><code># We will predict the Outcome for the test data
p&lt;-predict(glm_dia, dia_test)
# Choose a threshold 0.5 to calculate the accuracy of our model
p_05 &lt;- ifelse(p &gt; 0.5, 1, 0)
table(p_05, dia_test$Outcome)</code></pre>
<pre><code>##     
## p_05  0  1
##    0 88 23
##    1 12 31</code></pre>
<p>We will build a confusion matrix to calculate how accurate our model is in this particular random train/test split and at 0.5 threshold level.</p>
<pre class="r"><code>conf_mat &lt;- table(p_05, dia_test$Outcome)
accuracy &lt;- sum(diag(conf_mat))/sum(conf_mat)
accuracy</code></pre>
<pre><code>## [1] 0.7727273</code></pre>
<p><strong>roc</strong> function pROC package, can plot us a ROC curve which tests accuracy of our model at multiple threshold levels and is a good estimate on how well our model is performing.</p>
<pre class="r"><code># Calculate AUC(Area under the curve)
roc(dia_test$Outcome, p)</code></pre>
<pre><code>## Setting levels: control = 0, case = 1</code></pre>
<pre><code>## Setting direction: controls &lt; cases</code></pre>
<pre><code>## 
## Call:
## roc.default(response = dia_test$Outcome, predictor = p)
## 
## Data: p in 100 controls (dia_test$Outcome 0) &lt; 54 cases (dia_test$Outcome 1).
## Area under the curve: 0.8446</code></pre>
<p>However, this process is little fragile, presence or absence of a single outlier might vastly change the results you might get from a given random train/test split.</p>
<p>A better approach than a simple train/test split is using multiple test sets and averaging their accuracies.</p>
<p>Let’s test that. I will create 1, 30 or 1000 random test sets, build models and compare their accuracies.</p>
<div id="how-to-apply-multiple-traintest-split" class="section level4">
<h4>How to apply multiple train/test split</h4>
<p>To do this, I will <strong>write a function</strong> where I can choose number of independent train/test splits.</p>
<p>It will return me an average value of the accuracy(auc) of the model after chosen number of iteration. The higher the number of random splits the more stable your estimated AUC will be.</p>
<p>Let’s see how it will work out for our diabetes patients.</p>
<pre class="r"><code># I will define my function as follows
multi_split &lt;- function(x){
sample_rows &lt;- list()
dia_train &lt;- list()
dia_test &lt;- list()
glm &lt;- list()
p &lt;-  list()
roc_auc &lt;- list()
for(i in 1:x){
  sample_rows[[i]] &lt;- sample(nrow(diabetes), nrow(diabetes) * 0.8)
  # Create the training dataset
  dia_train[[i]] &lt;- diabetes[sample_rows[[i]], ]
  # Create the test dataset
  dia_test[[i]] &lt;- diabetes[-sample_rows[[i]], ]
  glm[[i]] &lt;- glm(Outcome ~ .,data = dia_train[[i]], family = &quot;binomial&quot;)
  p[[i]] &lt;- predict(glm[[i]], dia_test[[i]])
  
  # Calculate AUC for all &quot;x&quot; number of random splits
  roc_auc[[i]] &lt;- roc(dia_test[[i]]$Outcome, p[[i]])$auc[1]
  glm_mean &lt;- mean(unlist(roc_auc))
}
print(mean(unlist(roc_auc)))
}</code></pre>
<p>Let’s calculate the average AUC of our model after different number of random splits.</p>
<p>I will run my <strong>multi_split() function</strong> 3x for 1, 30 and 1000 random train/test splits. I can then compare variances at each level of sampling.</p>
<p>Here are the results from my multi_site function at each randomization.</p>
<pre class="r"><code>auc_1_1 &lt;- multi_split(1)</code></pre>
<pre><code>## [1] 0.8737245</code></pre>
<pre class="r"><code>auc_1_2 &lt;- multi_split(1)</code></pre>
<pre><code>## [1] 0.8271277</code></pre>
<pre class="r"><code>auc_1_3 &lt;- multi_split(1)</code></pre>
<pre><code>## [1] 0.824344</code></pre>
<pre class="r"><code>auc_30_1 &lt;- multi_split(30)</code></pre>
<pre><code>## [1] 0.8399321</code></pre>
<pre class="r"><code>auc_30_2 &lt;- multi_split(30)</code></pre>
<pre><code>## [1] 0.8492238</code></pre>
<pre class="r"><code>auc_30_3 &lt;- multi_split(30)</code></pre>
<pre><code>## [1] 0.8294277</code></pre>
<pre class="r"><code>auc_1000_1 &lt;- multi_split(1000)</code></pre>
<pre><code>## [1] 0.8356283</code></pre>
<pre class="r"><code>auc_1000_2 &lt;- multi_split(1000)</code></pre>
<pre><code>## [1] 0.836047</code></pre>
<pre class="r"><code>auc_1000_3 &lt;- multi_split(1000)</code></pre>
<pre><code>## [1] 0.8345809</code></pre>
<p>Let’s compare Variance levels at <strong>1, 30 and 1000</strong> random splits</p>
<pre class="r"><code>var(c(auc_1_1, auc_1_2, auc_1_3))</code></pre>
<pre><code>## [1] 0.0007695739</code></pre>
<pre class="r"><code>var(c(auc_30_1, auc_30_2, auc_30_3))</code></pre>
<pre><code>## [1] 9.809343e-05</code></pre>
<pre class="r"><code>var(c(auc_1000_1, auc_1000_2, auc_1000_3))</code></pre>
<pre><code>## [1] 5.702925e-07</code></pre>
<p>What we see here as we increase the number of iterations to 30 and 1000 the variability
gradually stabilizes around a trustable AUC of <code>0.835</code>.</p>
<p>Seeing is believing. Let’s plot it.</p>
<pre class="r"><code># Create a data.frame containing accuracies
random_1X &lt;- c(auc_1_1, auc_1_2, auc_1_3)
random_30X &lt;- c(auc_30_1, auc_30_2, auc_30_3)
random_1000X &lt;- c(auc_1000_1, auc_1000_2, auc_1000_3)

df_r &lt;- data.frame(random_1X, random_30X, random_1000X)
df_r</code></pre>
<pre><code>##   random_1X random_30X random_1000X
## 1 0.8737245  0.8399321    0.8356283
## 2 0.8271277  0.8492238    0.8360470
## 3 0.8243440  0.8294277    0.8345809</code></pre>
<pre class="r"><code># Here, I will reformat my data for easy plotting by using gather() function from tidyr
# It takes multiple columns, and gathers them into key-value pairs: it makes “wide” data longer.
df_long &lt;- gather(df_r, sampling, auc)
df_long</code></pre>
<pre><code>##       sampling       auc
## 1    random_1X 0.8737245
## 2    random_1X 0.8271277
## 3    random_1X 0.8243440
## 4   random_30X 0.8399321
## 5   random_30X 0.8492238
## 6   random_30X 0.8294277
## 7 random_1000X 0.8356283
## 8 random_1000X 0.8360470
## 9 random_1000X 0.8345809</code></pre>
<pre class="r"><code>df_long$sampling &lt;- factor(df_long$sampling, levels = c(&quot;random_1X&quot;, &quot;random_30X&quot;, &quot;random_1000X&quot;))

# 
model_variation &lt;- ggplot(df_long, aes(y=auc, x=sampling, fill=sampling)) + geom_boxplot() + theme(text = element_text(size=15), axis.title.x=element_blank(), legend.position = &quot;none&quot;) + ggtitle(&quot;Variation in model performance&quot;)
model_variation</code></pre>
<p><img src="/post/2019-10-01-can-machine-learning-change-your-life-style_files/figure-html/change%20in%20variance%20plot-1.png" width="672" /></p>
<p>Great. We have an estimate of our model performance after 1000 random train/test splits. This process is also called <strong>Monte-Carlo Cross validation.</strong> This approach might give you a less variable, but more biased estimate.</p>
<p>A more common approach to estimate model performance is <strong>k-Fold cross Validation.</strong> Where the samples divided into k-folds and one fold is used as a test set, and the remaining k-1 as the training set. This process is run k times until all folds appear once in the test sample.</p>
</div>
</div>
<div id="logistic-regression-model-with-k-fold-cross-validation" class="section level2">
<h2>Logistic regression model with k-fold Cross Validation</h2>
<p>I will switch here to caret package. With the <strong>Train()</strong> function we can test different types of machine learning algorithms and set the cross validation parameters.</p>
<p>To make the models below comparable I will create <strong>a custom cross validation fold object (d_folds)</strong> that I can apply to multiple models.</p>
<p>I will repeat the logistic regression model with 5 fold cross validation and then we can compare it to monte carlo cross validation.</p>
<pre class="r"><code># Convert Outcome to a factor with two levels
diabetes$Outcome &lt;- ifelse(diabetes$Outcome == 1, &quot;Yes&quot;, &quot;No&quot;)
outcome &lt;- diabetes$Outcome
d_folds &lt;- createFolds(outcome, k=5)

# Create a dataframe without the outcome column
diab &lt;- diabetes[,-9]

# MyControl
myControl &lt;- trainControl(
    summaryFunction = twoClassSummary,
    classProbs = TRUE,
    verboseIter = TRUE,
    savePredictions = TRUE,
    index = d_folds
)
# Model_glm
model_glm &lt;- train(x = diab, y = outcome,
                   metric = &quot;ROC&quot;,
                   method = &quot;glm&quot;,
                   family = binomial(),
                   trControl = myControl
)</code></pre>
<pre><code>## + Fold1: parameter=none 
## - Fold1: parameter=none 
## + Fold2: parameter=none 
## - Fold2: parameter=none 
## + Fold3: parameter=none 
## - Fold3: parameter=none 
## + Fold4: parameter=none 
## - Fold4: parameter=none 
## + Fold5: parameter=none 
## - Fold5: parameter=none 
## Aggregating results
## Fitting final model on full training set</code></pre>
<pre class="r"><code>model_glm</code></pre>
<pre><code>## Generalized Linear Model 
## 
## 768 samples
##   8 predictor
##   2 classes: &#39;No&#39;, &#39;Yes&#39; 
## 
## No pre-processing
## Resampling: Bootstrapped (5 reps) 
## Summary of sample sizes: 154, 153, 153, 154, 154 
## Resampling results:
## 
##   ROC        Sens   Spec    
##   0.8136093  0.844  0.577431</code></pre>
<p>Here, My model performance is <code>0.8136093</code></p>
</div>
<div id="glmnet-model" class="section level2">
<h2>Glmnet model</h2>
<pre class="r"><code># Model
model_glmnet &lt;- train(x = diab, y = outcome,
                   metric = &quot;ROC&quot;,
                   method = &quot;glmnet&quot;, tuneGrid = expand.grid(
                          alpha = 0:1,
                          lambda = seq(0.0001, 1, length = 20)
                      ),
                   trControl = myControl
)</code></pre>
<pre class="r"><code>model_glmnet</code></pre>
<pre><code>## glmnet 
## 
## 768 samples
##   8 predictor
##   2 classes: &#39;No&#39;, &#39;Yes&#39; 
## 
## No pre-processing
## Resampling: Bootstrapped (5 reps) 
## Summary of sample sizes: 154, 153, 153, 154, 154 
## Resampling results across tuning parameters:
## 
##   alpha  lambda      ROC        Sens    Spec       
##   0      0.00010000  0.8201210  0.8615  0.554096935
##   0      0.05272632  0.8227469  0.8725  0.541977831
##   0      0.10535263  0.8239613  0.8880  0.506537709
##   0      0.15797895  0.8242214  0.9005  0.482290806
##   0      0.21060526  0.8240544  0.9115  0.444025212
##   0      0.26323158  0.8238034  0.9210  0.420725929
##   0      0.31585789  0.8233937  0.9290  0.395548794
##   0      0.36848421  0.8230260  0.9365  0.357313627
##   0      0.42111053  0.8228119  0.9430  0.331201913
##   0      0.47373684  0.8224972  0.9505  0.306955010
##   0      0.52636316  0.8222639  0.9575  0.276166051
##   0      0.57898947  0.8220894  0.9615  0.254705499
##   0      0.63161579  0.8219008  0.9670  0.238852423
##   0      0.68424211  0.8217353  0.9690  0.217396218
##   0      0.73686842  0.8215489  0.9705  0.200604216
##   0      0.78949474  0.8214394  0.9725  0.178235166
##   0      0.84212105  0.8212995  0.9755  0.157704847
##   0      0.89474737  0.8210990  0.9785  0.138109107
##   0      0.94737368  0.8209896  0.9800  0.125976962
##   0      1.00000000  0.8208614  0.9805  0.111980004
##   1      0.00010000  0.8141708  0.8450  0.575553141
##   1      0.05272632  0.8232373  0.9040  0.505646599
##   1      0.10535263  0.8064789  0.9490  0.348028689
##   1      0.15797895  0.7982626  0.9865  0.118687242
##   1      0.21060526  0.7913587  0.9995  0.002803738
##   1      0.26323158  0.5552114  1.0000  0.000000000
##   1      0.31585789  0.5000000  1.0000  0.000000000
##   1      0.36848421  0.5000000  1.0000  0.000000000
##   1      0.42111053  0.5000000  1.0000  0.000000000
##   1      0.47373684  0.5000000  1.0000  0.000000000
##   1      0.52636316  0.5000000  1.0000  0.000000000
##   1      0.57898947  0.5000000  1.0000  0.000000000
##   1      0.63161579  0.5000000  1.0000  0.000000000
##   1      0.68424211  0.5000000  1.0000  0.000000000
##   1      0.73686842  0.5000000  1.0000  0.000000000
##   1      0.78949474  0.5000000  1.0000  0.000000000
##   1      0.84212105  0.5000000  1.0000  0.000000000
##   1      0.89474737  0.5000000  1.0000  0.000000000
##   1      0.94737368  0.5000000  1.0000  0.000000000
##   1      1.00000000  0.5000000  1.0000  0.000000000
## 
## ROC was used to select the optimal model using the largest value.
## The final values used for the model were alpha = 0 and lambda = 0.1579789.</code></pre>
<pre class="r"><code>plot(model_glmnet)</code></pre>
<p><img src="/post/2019-10-01-can-machine-learning-change-your-life-style_files/figure-html/print%20Glmnet%20model-1.png" width="672" /></p>
<p>As we see in the plot, ridge regression (alpha = 0) performed better than the lasso at all lambda values.</p>
<p>Glmnet model performance is <code>0.8242214</code></p>
</div>
<div id="random-forest-model" class="section level2">
<h2>Random forest model</h2>
<p>One of the big diferences between random forest and linear models is that they require “tuning.”</p>
<p>Hyperparameters –&gt; How the model is fit. Selected by hand.</p>
<p>advantages: no need to log transform or normalize,
but they are less interpretable and slower than glmnet.</p>
<p>Random forests <strong>capture threshold effects and variable interactions. both of which occur often in real world data</strong></p>
<p><strong>mtry</strong> is the number of variables used at each split point in individual decision tree that make up the rf. Default is 3, I will use here 8.</p>
<p>tuneLength = how many different mtry values to be tested.</p>
<pre class="r"><code># Random forest model
model_rf &lt;- train(x = diab, y = outcome,
                   tuneLength = 8,
                   metric = &quot;ROC&quot;,
                   method = &quot;ranger&quot;,
                   trControl = myControl
)</code></pre>
<pre class="r"><code>model_rf</code></pre>
<pre><code>## Random Forest 
## 
## 768 samples
##   8 predictor
##   2 classes: &#39;No&#39;, &#39;Yes&#39; 
## 
## No pre-processing
## Resampling: Bootstrapped (5 reps) 
## Summary of sample sizes: 154, 153, 153, 154, 154 
## Resampling results across tuning parameters:
## 
##   mtry  splitrule   ROC        Sens    Spec     
##   2     gini        0.8155919  0.8565  0.5410389
##   2     extratrees  0.8247223  0.8730  0.5419474
##   3     gini        0.8142703  0.8490  0.5596827
##   3     extratrees  0.8241664  0.8650  0.5550185
##   4     gini        0.8098886  0.8440  0.5559617
##   4     extratrees  0.8244122  0.8595  0.5671376
##   5     gini        0.8096393  0.8475  0.5596914
##   5     extratrees  0.8244900  0.8550  0.5708498
##   6     gini        0.8075402  0.8460  0.5578309
##   6     extratrees  0.8231397  0.8530  0.5755401
##   7     gini        0.8063892  0.8415  0.5662117
##   7     extratrees  0.8213101  0.8515  0.5652728
##   8     gini        0.8058247  0.8335  0.5717931
##   8     extratrees  0.8209827  0.8485  0.5773788
## 
## Tuning parameter &#39;min.node.size&#39; was held constant at a value of 1
## ROC was used to select the optimal model using the largest value.
## The final values used for the model were mtry = 2, splitrule =
##  extratrees and min.node.size = 1.</code></pre>
<p>Random forest performance is <code>0.8247223</code></p>
</div>
<div id="gradient-boost-model" class="section level2">
<h2>Gradient boost model</h2>
<p>I will define manualy a grid to test hyperparameter values wider than set in default.</p>
<pre class="r"><code>grid &lt;- expand.grid(interaction.depth = c(1, 2, 3, 4, 5),
                 n.trees = (1:20)*50,  shrinkage = 0.01,
             n.minobsinnode = 10)
model_gbm &lt;- train(x = diab, y = outcome,
                   metric = &quot;ROC&quot;,
                   method = &quot;gbm&quot;,
                   tuneGrid = grid,
                   trControl = myControl
)</code></pre>
<pre class="r"><code>model_gbm</code></pre>
<pre><code>## Stochastic Gradient Boosting 
## 
## 768 samples
##   8 predictor
##   2 classes: &#39;No&#39;, &#39;Yes&#39; 
## 
## No pre-processing
## Resampling: Bootstrapped (5 reps) 
## Summary of sample sizes: 154, 153, 153, 154, 154 
## Resampling results across tuning parameters:
## 
##   interaction.depth  n.trees  ROC        Sens    Spec      
##   1                    50     0.7996312  0.9850  0.09252336
##   1                   100     0.8103617  0.9505  0.32756357
##   1                   150     0.8153748  0.9275  0.42350793
##   1                   200     0.8180549  0.9100  0.48598131
##   1                   250     0.8213254  0.8965  0.51863943
##   1                   300     0.8221740  0.8860  0.52983699
##   1                   350     0.8210830  0.8815  0.53729189
##   1                   400     0.8218884  0.8740  0.55409694
##   1                   450     0.8222721  0.8680  0.55874375
##   1                   500     0.8212831  0.8625  0.55593567
##   1                   550     0.8222189  0.8595  0.56525973
##   1                   600     0.8210507  0.8540  0.56620300
##   1                   650     0.8206810  0.8510  0.56806781
##   1                   700     0.8197731  0.8495  0.56806781
##   1                   750     0.8194073  0.8495  0.57180178
##   1                   800     0.8179990  0.8460  0.57459683
##   1                   850     0.8173591  0.8435  0.57459683
##   1                   900     0.8167653  0.8400  0.57272332
##   1                   950     0.8159870  0.8395  0.57366225
##   1                  1000     0.8155800  0.8375  0.57738752
##   2                    50     0.8097645  0.9705  0.19896110
##   2                   100     0.8153114  0.9225  0.42633341
##   2                   150     0.8182821  0.9040  0.47947837
##   2                   200     0.8214800  0.8910  0.51491415
##   2                   250     0.8209545  0.8780  0.53262769
##   2                   300     0.8209278  0.8655  0.54569007
##   2                   350     0.8203395  0.8595  0.55967398
##   2                   400     0.8193341  0.8560  0.56620735
##   2                   450     0.8187081  0.8520  0.57274071
##   2                   500     0.8177495  0.8475  0.58300369
##   2                   550     0.8172341  0.8470  0.58206912
##   2                   600     0.8160518  0.8430  0.58579005
##   2                   650     0.8150557  0.8335  0.58580309
##   2                   700     0.8142389  0.8285  0.58765486
##   2                   750     0.8129551  0.8265  0.59045860
##   2                   800     0.8114235  0.8235  0.58859378
##   2                   850     0.8106544  0.8230  0.58951967
##   2                   900     0.8098655  0.8225  0.58952402
##   2                   950     0.8089927  0.8195  0.59231471
##   2                  1000     0.8085903  0.8185  0.59044990
##   3                    50     0.8124471  0.9675  0.23434471
##   3                   100     0.8166505  0.9160  0.43008042
##   3                   150     0.8183159  0.8875  0.50374701
##   3                   200     0.8170682  0.8700  0.52424690
##   3                   250     0.8167332  0.8610  0.54665942
##   3                   300     0.8170788  0.8535  0.55690067
##   3                   350     0.8155400  0.8470  0.57181917
##   3                   400     0.8140688  0.8410  0.57181482
##   3                   450     0.8124477  0.8355  0.57367529
##   3                   500     0.8114718  0.8325  0.57367963
##   3                   550     0.8100906  0.8275  0.57740926
##   3                   600     0.8092354  0.8230  0.58113888
##   3                   650     0.8082420  0.8220  0.58859813
##   3                   700     0.8065477  0.8190  0.58766355
##   3                   750     0.8062263  0.8160  0.58858944
##   3                   800     0.8044913  0.8130  0.58765486
##   3                   850     0.8029262  0.8125  0.58765486
##   3                   900     0.8020108  0.8110  0.58858944
##   3                   950     0.8016405  0.8105  0.59045860
##   3                  1000     0.8011373  0.8090  0.59232775
##   4                    50     0.8139509  0.9640  0.24734188
##   4                   100     0.8150242  0.9120  0.43657900
##   4                   150     0.8179537  0.8850  0.49533145
##   4                   200     0.8176002  0.8710  0.53356227
##   4                   250     0.8162216  0.8615  0.55220170
##   4                   300     0.8159643  0.8490  0.56901543
##   4                   350     0.8141087  0.8445  0.57553141
##   4                   400     0.8131285  0.8430  0.57832645
##   4                   450     0.8114524  0.8385  0.58020430
##   4                   500     0.8104583  0.8335  0.58671158
##   4                   550     0.8089872  0.8265  0.58764182
##   4                   600     0.8078067  0.8240  0.59137144
##   4                   650     0.8064856  0.8230  0.59418387
##   4                   700     0.8051274  0.8200  0.59044121
##   4                   750     0.8038530  0.8205  0.59324495
##   4                   800     0.8030680  0.8205  0.59699196
##   4                   850     0.8023061  0.8190  0.59793088
##   4                   900     0.8011695  0.8185  0.59606607
##   4                   950     0.8000060  0.8160  0.59326668
##   4                  1000     0.7988982  0.8140  0.59045860
##   5                    50     0.8124004  0.9640  0.23430124
##   5                   100     0.8128960  0.9085  0.43658770
##   5                   150     0.8164498  0.8875  0.50560313
##   5                   200     0.8159795  0.8755  0.53263638
##   5                   250     0.8154252  0.8595  0.55782221
##   5                   300     0.8146149  0.8500  0.56622473
##   5                   350     0.8132774  0.8420  0.57460987
##   5                   400     0.8123588  0.8405  0.58207781
##   5                   450     0.8111443  0.8355  0.58207781
##   5                   500     0.8090119  0.8295  0.58767225
##   5                   550     0.8078390  0.8255  0.58488589
##   5                   600     0.8068005  0.8255  0.58954575
##   5                   650     0.8047019  0.8230  0.59045425
##   5                   700     0.8033723  0.8215  0.59231906
##   5                   750     0.8024794  0.8210  0.58951967
##   5                   800     0.8019000  0.8190  0.59232341
##   5                   850     0.8006418  0.8185  0.59512715
##   5                   900     0.7998935  0.8170  0.59605303
##   5                   950     0.7984835  0.8170  0.59698326
##   5                  1000     0.7970453  0.8165  0.59418822
## 
## Tuning parameter &#39;shrinkage&#39; was held constant at a value of 0.01
## 
## Tuning parameter &#39;n.minobsinnode&#39; was held constant at a value of 10
## ROC was used to select the optimal model using the largest value.
## The final values used for the model were n.trees = 450,
##  interaction.depth = 1, shrinkage = 0.01 and n.minobsinnode = 10.</code></pre>
<p>Gradient boost model performance is <code>0.8222721</code></p>
</div>
<div id="naive-bayes-model" class="section level2">
<h2>Naive Bayes model</h2>
<pre class="r"><code>model_nb &lt;- train(x = diab, y = outcome,
                   metric = &quot;ROC&quot;,
                   method = &quot;nb&quot;,
                   trControl = myControl
)</code></pre>
<pre class="r"><code>model_nb</code></pre>
<pre><code>## Naive Bayes 
## 
## 768 samples
##   8 predictor
##   2 classes: &#39;No&#39;, &#39;Yes&#39; 
## 
## No pre-processing
## Resampling: Bootstrapped (5 reps) 
## Summary of sample sizes: 154, 153, 153, 154, 154 
## Resampling results across tuning parameters:
## 
##   usekernel  ROC        Sens    Spec     
##   FALSE      0.8029047  0.8280  0.5801608
##    TRUE      0.7895701  0.8145  0.5745447
## 
## Tuning parameter &#39;fL&#39; was held constant at a value of 0
## Tuning
##  parameter &#39;adjust&#39; was held constant at a value of 1
## ROC was used to select the optimal model using the largest value.
## The final values used for the model were fL = 0, usekernel = FALSE
##  and adjust = 1.</code></pre>
<p>Naive Bayes model performance is <code>0.8029047</code></p>
<pre class="r"><code>models &lt;- c(&quot;glm&quot;, &quot;glmnet&quot;, &quot;rf&quot;, &quot;gbm&quot;, &quot;naive&quot;)
glm &lt;- max(model_glm$results$ROC)
glmnet &lt;- max(model_glmnet$results$ROC)
rf &lt;- max(model_rf$results$ROC)
gbm &lt;- max(model_gbm$results$ROC)
naive &lt;- max(model_nb$results$ROC)
AUC &lt;- c(glm, glmnet, rf, gbm, naive)
df &lt;- data.frame(models, AUC)
df&lt;- df[order(df[,2], decreasing=TRUE), ]
knitr::kable(df)</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:left;">
models
</th>
<th style="text-align:right;">
AUC
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
3
</td>
<td style="text-align:left;">
rf
</td>
<td style="text-align:right;">
0.8247223
</td>
</tr>
<tr>
<td style="text-align:left;">
2
</td>
<td style="text-align:left;">
glmnet
</td>
<td style="text-align:right;">
0.8242214
</td>
</tr>
<tr>
<td style="text-align:left;">
4
</td>
<td style="text-align:left;">
gbm
</td>
<td style="text-align:right;">
0.8222721
</td>
</tr>
<tr>
<td style="text-align:left;">
1
</td>
<td style="text-align:left;">
glm
</td>
<td style="text-align:right;">
0.8136093
</td>
</tr>
<tr>
<td style="text-align:left;">
5
</td>
<td style="text-align:left;">
naive
</td>
<td style="text-align:right;">
0.8029047
</td>
</tr>
</tbody>
</table>
<p>Here, we found <code>rf</code> model performed the best, and also there are not big differences between the models.</p>
</div>
<div id="future-thoughts" class="section level2">
<h2>Future thoughts</h2>
<p>I used different machine learning algorithms to predict Diabetes. Models showed similar performances except the naives bayes which performed worst. <strong>As we saw, our simple glm model performance was very close to other more advanced algorithms.</strong></p>
<p>We can help doctors to predict <strong>Diabetes with accuracy around 83%</strong> by using 8 simple medical parameters.</p>
<p>Given current speed in generation and collection of types data by including additional predictors we can build even better models.</p>
<p>Until next time!</p>
<p>Serdar</p>
</div>
</div>
